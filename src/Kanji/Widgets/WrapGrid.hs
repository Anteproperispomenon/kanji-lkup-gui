{-|
Module      : Kanji.Widgets.WrapGrid
Copyright   : (c) 2023 David Wilson
License     : BSD-3-Clause (see the LICENSE file)
Maintainer  : David Wilson

A grid container widget where contents wrap
from one line to the next.


-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE Strict #-}

module Kanji.Widgets.WrapGrid (
  -- * Configuration
  WGridCfg,
  CmbMaxMainCells(..),
  -- * Constructors
  hwgrid,
  hwgrid_,
  vwgrid,
  vwgrid_
) where

import Control.Applicative ((<|>))
import Control.Lens ((&), (^.), (.~), (%~))
import Data.Default
import Data.List (foldl')
import Data.Maybe
import Data.Sequence (Seq(..), (|>))

import qualified Data.Sequence as Seq

import Monomer.Helper (applyFnList)
import Monomer.Widgets.Container

import qualified Monomer.Lens as L

{-|
Configuration options for grid:

- 'childSpacing': spacing between the child widgets.
- 'sizeReqUpdater': allows modifying the 'SizeReq' generated by the grid.
-}
data WGridCfg = WGridCfg {
  _wgrcChildSpacing :: Maybe Double,
  _wgrcSizeReqUpdater :: [SizeReqUpdater],
  _wgrcMaxMainLength :: Maybe Int
}

instance Default WGridCfg where
  def = WGridCfg {
    _wgrcChildSpacing = Nothing,
    _wgrcSizeReqUpdater = [],
    _wgrcMaxMainLength = Nothing
  }

instance Semigroup WGridCfg where
  (<>) s1 s2 = WGridCfg {
    _wgrcChildSpacing = _wgrcChildSpacing s2 <|> _wgrcChildSpacing s1,
    _wgrcSizeReqUpdater = _wgrcSizeReqUpdater s1 <> _wgrcSizeReqUpdater s2,
    _wgrcMaxMainLength = _wgrcMaxMainLength s2 <|> _wgrcMaxMainLength s1
  }

instance Monoid WGridCfg where
  mempty = def

instance CmbChildSpacing WGridCfg where
  childSpacing_ spacing = def {
    _wgrcChildSpacing = Just spacing
  }

instance CmbSizeReqUpdater WGridCfg where
  sizeReqUpdater updater = def {
    _wgrcSizeReqUpdater = [updater]
  }

-- | Get the max number of cells along the main axis
class CmbMaxMainCells t where
  -- | Set the spacing to the default amount (may vary by container).
  -- maxMainCells :: t
  -- maxMainCells = 30
  -- | Set the max cells.
  maxMainCells :: Int -> t

instance CmbMaxMainCells WGridCfg where
  maxMainCells cells = def {
    _wgrcMaxMainLength = Just cells
  }

-- | Creates a grid of items that fill 
-- left-to-right, top-to-bottom. 
hwgrid
  :: Traversable t
  => t (WidgetNode s e)  -- ^ The list of items.
  -> WidgetNode s e      -- ^ The created grid.
hwgrid children = hwgrid_ def children

-- | Creates a grid of items that fill 
-- left-to-right, top-to-bottom. Accepts config.
hwgrid_
  :: Traversable t
  => [WGridCfg]           -- ^ The config options.
  -> t (WidgetNode s e)  -- ^ The list of items.
  -> WidgetNode s e      -- ^ The created grid.
hwgrid_ configs children = newNode where
  config = mconcat configs
  newNode = defaultWidgetNode "hwgrid" (makeFixedGrid True config)
    & L.children .~ foldl' (|>) Empty children

-- | Creates a grid of items that fill 
-- top-to-bottom, left-to-right. 
vwgrid
  :: Traversable t
  => t (WidgetNode s e)  -- ^ The list of items.
  -> WidgetNode s e      -- ^ The created grid.
vwgrid children = vwgrid_ def children

-- | Creates a grid of items that fill 
-- top-to-bottom, left-to-right. Accepts config.
vwgrid_
  :: Traversable t
  => [WGridCfg]           -- ^ The config options.
  -> t (WidgetNode s e)  -- ^ The list of items.
  -> WidgetNode s e      -- ^ The created grid.
vwgrid_ configs children = newNode where
  config = mconcat configs
  newNode = defaultWidgetNode "vwgrid" (makeFixedGrid False config)
    & L.children .~ foldl' (|>) Empty children

makeFixedGrid :: Bool -> WGridCfg -> Widget s e
makeFixedGrid isHorizontal config = widget where
  widget = createContainer () def {
    containerLayoutDirection = getLayoutDirection isHorizontal,
    containerGetSizeReq = getSizeReq,
    containerResize = resize
  }

  isVertical = not isHorizontal
  childSpacing = fromMaybe 0 (_wgrcChildSpacing config)
  maxCells = _wgrcMaxMainLength config

  getSizeReq wenv node children = newSizeReq where
    sizeReqFns = _wgrcSizeReqUpdater config
    vchildren = Seq.filter (_wniVisible . _wnInfo) children
    newSizeReqW = getDimSizeReq isHorizontal (_wniSizeReqW . _wnInfo) vchildren
    newSizeReqH = getDimSizeReq isVertical (_wniSizeReqH . _wnInfo) vchildren
    newSizeReq = applyFnList sizeReqFns (newSizeReqW, newSizeReqH)

  getDimSizeReq mainAxis accessor vchildren
    | Seq.null vreqs = fixedSize 0
    -- If horizontal
    | mainAxis = foldl1 sizeReqMergeSum (Seq.replicate nreqs maxSize) & L.fixed %~ (+ totalSpacing)
    -- If vertical
    | otherwise = maxSize
    where
      -- The size requests of all the children
      vreqs = accessor <$> vchildren
      nreqs = Seq.length vreqs
      -- The largest sizeReq of all the child widgets.
      ~maxSize = foldl1 sizeReqMergeMax vreqs
      totalSpacing = fromIntegral (nreqs - 1) * childSpacing

  resize wenv node viewport children = resized where
    style = currentStyle wenv node
    contentArea = fromMaybe def (removeOuterBounds style viewport)
    Rect l t w h = contentArea
    vchildren = Seq.filter (_wniVisible . _wnInfo) children
    nreqs     = Seq.length vchildren

    -- hmm...    
    wvreqs = (_wniSizeReqW . _wnInfo) <$> vchildren
    hvreqs = (_wniSizeReqH . _wnInfo) <$> vchildren

    -- hmm...
    ~wmaxSize = foldl1 sizeReqMergeMax wvreqs
    ~hmaxSize = foldl1 sizeReqMergeMax hvreqs

    totalSpacingW = fromIntegral (max 0 (cols - 1)) * childSpacing
    totalSpacingH = fromIntegral (max 0 (rows - 1)) * childSpacing
    
    -- here we go
    -- need to rewrite this
    -- cols = if isHorizontal then length vchildren else 1
    -- rows = if isHorizontal then 1 else length vchildren

    -- okay
    (cols,rows)
      | nreqs == 0   = (1,1)
      | isHorizontal = (xnums ,ynums')
      | otherwise    = (xnums',ynums )
      where
        xfixed  = wmaxSize ^. L.fixed
        yfixed  = hmaxSize ^. L.fixed
        xnums
          | (Just mx) <- maxCells
          = min mx (max 1 (floor $ w / xfixed))
          | otherwise = max 1 (floor $ w / xfixed) -- to ensure at least one column
        ynums 
          | (Just mx) <- maxCells
          = min mx (max 1 (floor $ h / yfixed))
          | otherwise = max 1 (floor $ h / yfixed)
        (xq,xr) = nreqs `quotRem` xnums
        (yq,yr) = nreqs `quotRem` ynums
        xnums'  = if yr == 0 then yq else yq + 1
        ynums'  = if xr == 0 then xq else xq + 1

    cw = if cols > 0 then (w - totalSpacingW) / fromIntegral cols else 0
    ch = if rows > 0 then (h - totalSpacingH) / fromIntegral rows else 0

    -- where to position each child
    cx i
      | rows == 0 = 0
      | isHorizontal = l + fromIntegral (i `rem` cols) * cw + spacingOffset (i `rem` cols)
      | otherwise = l + fromIntegral (i `quot` rows) * cw + spacingOffset (i `quot` rows)
    cy i
      | cols == 0 = 0
      | isVertical = t + fromIntegral (i `rem` rows) * ch + spacingOffset (i `rem` rows)
      | otherwise = t + fromIntegral (i `quot` cols) * ch + spacingOffset (i `quot` cols)
    spacingOffset i =
      fromIntegral i * childSpacing

    foldHelper (currAreas, index) child = (newAreas, newIndex) where
      (newIndex, newViewport)
        | child ^. L.info . L.visible = (index + 1, calcViewport index)
        | otherwise = (index, def)
      newArea = newViewport
      newAreas = currAreas |> newArea
    calcViewport i = Rect (cx i) (cy i) cw ch

    assignedAreas = fst $ foldl' foldHelper (Seq.empty, 0) children
    resized = (resultNode node, assignedAreas)